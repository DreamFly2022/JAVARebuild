# MySQL 高可用和读写分离

[toc]

##  一、从单机到集群

### 1.1 单机MySQL数据库到几个问题

随着数据量的增大，读写并发的增加，系统可用性要求的提升，单机 MySQL 面临：

1. 容量有限，难以扩容；

2. 读写压力，QPS 过大，特别是分析类需求会影响到业务事务；

   - QPS 每秒查询率。

   - TPS 吞吐量，指系统在单位时间内处理请求的数量

     > 一般业务系统，要求TPS能达到5k～8k

3. 可用性不足，宕机问题

   不可靠

### 1.2 单机MySQL到技术演进

（1）读写压力==》多机机群==》主从复制

（2）高可用===》故障转移==》MHA/MGR/Orchestrator

（3）容量问题=》数据库拆分=》分库分表

> 垂直拆分、水平拆分

**通过操作N个数据库，如何保证数据库多一致性？**

（通过上面的技术演进带来的副作用）

（4）一致性问题=》分布式事务=》XA/柔性事务

解决方案：分布式事务，

具体做法：XA/柔性事务

> 如果XA对性能影响太大，可以考虑用柔性事务

再往后就是分布式数据库了。

![MySQL技术演进](./photos/001MySQL技术演进.png)

## 二、MySQL的主从复制

### 2.1 核心

1. 主库写binlog；
2. 从库relay log；

> 2000年，MySQL 3.23.15版本引入了复制
>
> 2002年，MySQL 4.0.2版本分离 IO 和 SQL 线程，引入了 relay log
>
> 2010年，MySQL 5.5版本引入半同步复制
>
> 2016年，MySQL 在5.7.17中引入 InnoDB Group Replication



![MySQL主从复制](./photos/002MySQL主从复制.png)

### 2.2 binlog

binlog 的格式有三种形式：

（1）Row

第一种方式，记录行内容，非常精确，但可能会导致日志变得特别大。不仅包含需要改的信息，还包含上下文信息。

（2）Statement

第二种方式，记录SQL（insert、update、delete）。

（3）Mixed

第三种方式，混合上面两种形式。



怎么查看binlog？

mysql文件夹下，有很多类型mysql-bin.000005这样的文件，通过命令行：`mysqlbinlog -vv mysqlbin.000005`进行查看。

### 2.3 方案一，异步复制：传统主从复制

异步复制：传统主从复制--2000年，MySQL 3.23.15版本引入了 Replication

Primary-Secondary Replication 传统主从复制：

主库（Source）：执行SQL（execute）----->（在事务提交(commit)之前）记录binlog------>提交（commit）

从库（Replica1）：relay log（从主库拉取binlog，有偏移量，类似消息队列）----->应用(apply)--->binlog--->提交

**异步复制（这个都是异步的）：网络或机器故障，会造成数据不一致。**

![MySQL传统主从复制](./photos/003MySQL传统主从复制.png)

### 2.4 方案二，半同步复制，需要启用插件

半同步：不管有多少个从库在复制，每个事务只要有一个从库告诉我 它已经拿到了我发给它的log，这个时候主库就提交了。也就是说，主库把提交延迟到至少有一个从库拿到了我发给它的消息（ACK）。

> 保证Source和Replica最终一致性（保证至少有一个从库和主库是同步的）

![半同步复制](./photos/004半同步复制.png)

### 2.5 方案三：组复制，MySQL Group Replication（MGR）

组复制：基于分布式Paxos协议实现组复制，保证数据一致性。

通过协议的方式，保证主从一致。

![MySQL组复制](./photos/005MySQL组复制.png)

### 2.6 主从复制的演示:Ubuntu

[windows系统演示](./document/ms.md)

[从官网查询下载Ubuntu平台的mysql入口](https://cdn.mysql.com/archives/mysql-5.7/mysql-community-server_5.7.35-1ubuntu18.04_amd64.deb)

#### (1) 第一种方案：在一台ubuntu服务器上启动两个mysql

[在一台ubuntu服务器上启动两个mysql服务进行演示](./2021-11-24-MySQL主从复制演示-在ubuntu上启动两个mysql服务.md)，最终并没有演示成功，自己才想，原因是启动服务的时候，需要指定-S参数。尝试第二种方案，使用docker。

> 后来发现，失败的原因是配置副本节点的时候忘了执行 `START SLAVE; `, 执行之后就能成功了

#### (2) 第二种方案，在ubuntu服务器上利用docker启动两个mysql服务

[MySQL主从复制演示-在ubuntu服务器上利用docker启动两个mysql服务](./2021-11-25-MySQL主从复制演示-在ubuntu服务器上利用docker启动两个mysql服务.md)。

补充：

> 数据库的标准实现中，有三层级：catelog、schema、database

### 2.7 半同步复制，以插件形式存在

```
-- 查看插件
show plugins;
```

> /usr/local/mysql/lib/plugin/semisync_master.so
>
> /usr/local/mysql/lib/plugin/semisync_slave.so

### 2.8 组复制，以插件形式存在

> /usr/local/mysql/lib/plugin/group_replication.so

[**MySQL 设置基于GTID的复制**](https://blog.51cto.com/yueyinsha/2086045) ：是为了让所有 relay log，有个像链表一样的顺序；

> 在上面2.6 的演示中，relay log每一段之间没有任务联系，那么它在执行的时候，是否会严格按照事务的顺序，是不知道的。
>
> GTID的机制是：每次发送的一条事务，都会带一个，我下一个ID是啥。这样我的从库在做relay的时候，就会知道我这些事务相互之间的关系。

自己实践后，也补充了一篇博客：[]()

